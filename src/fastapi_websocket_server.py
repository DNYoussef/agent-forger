#!/usr/bin/env python3\n\"\"\"\nFastAPI WebSocket Server\n=======================\n\nFastAPI-based WebSocket server that can run alongside the existing Flask server.\nProvides WebSocket endpoints for real-time progress streaming.\nOffers HTTP fallback endpoints for compatibility.\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Any\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n# Pydantic models for API responses\nclass ProgressMetrics(BaseModel):\n    loss: float = 0.0\n    perplexity: float = 0.0\n    grokProgress: int = 0\n    currentStep: int = 0\n    totalSteps: int = 1000\n    currentModel: int = 1\n    totalModels: int = 3\n    learningRate: float = 0.001\n    accuracy: float = 0.0\n\n\nclass ProgressUpdate(BaseModel):\n    sessionId: str\n    eventType: str\n    metrics: ProgressMetrics\n    status: str = \"running\"\n    timestamp: str = None\n    message: Optional[str] = None\n\n    def __init__(self, **data):\n        if 'timestamp' not in data or data['timestamp'] is None:\n            data['timestamp'] = datetime.now().isoformat()\n        super().__init__(**data)\n\n\nclass ErrorEvent(BaseModel):\n    sessionId: str\n    eventType: str = \"training_error\"\n    error: str\n    timestamp: str = None\n    status: str = \"error\"\n\n    def __init__(self, **data):\n        if 'timestamp' not in data or data['timestamp'] is None:\n            data['timestamp'] = datetime.now().isoformat()\n        super().__init__(**data)\n\n\nclass WebSocketManager:\n    \"\"\"Manages WebSocket connections and broadcasting.\"\"\"\n\n    def __init__(self):\n        # Dict[session_id, List[WebSocket]]\n        self.active_connections: Dict[str, List[WebSocket]] = {}\n        # Dict[session_id, latest_data]\n        self.session_data: Dict[str, Dict[str, Any]] = {}\n        self.connection_metadata: Dict[WebSocket, Dict[str, Any]] = {}\n\n    async def connect(self, websocket: WebSocket, session_id: str):\n        \"\"\"Accept WebSocket connection and add to session room.\"\"\"\n        await websocket.accept()\n        \n        if session_id not in self.active_connections:\n            self.active_connections[session_id] = []\n        \n        self.active_connections[session_id].append(websocket)\n        \n        # Store connection metadata\n        self.connection_metadata[websocket] = {\n            'session_id': session_id,\n            'connected_at': datetime.now().isoformat(),\n            'last_ping': datetime.now().isoformat()\n        }\n        \n        # Initialize session data if not exists\n        if session_id not in self.session_data:\n            self.session_data[session_id] = {\n                'created_at': datetime.now().isoformat(),\n                'last_update': datetime.now().isoformat(),\n                'metrics': ProgressMetrics().dict(),\n                'status': 'waiting',\n                'connection_count': 0\n            }\n        \n        self.session_data[session_id]['connection_count'] = len(self.active_connections[session_id])\n        \n        logger.info(f\"WebSocket connected to session {session_id}. Total connections: {len(self.active_connections[session_id])}\")\n        \n        # Send current session state\n        await self.send_to_websocket(websocket, {\n            'type': 'session_joined',\n            'sessionId': session_id,\n            'currentState': self.session_data[session_id]['metrics'],\n            'status': self.session_data[session_id]['status'],\n            'timestamp': datetime.now().isoformat()\n        })\n\n    def disconnect(self, websocket: WebSocket):\n        \"\"\"Remove WebSocket connection.\"\"\"\n        if websocket in self.connection_metadata:\n            session_id = self.connection_metadata[websocket]['session_id']\n            \n            # Remove from active connections\n            if session_id in self.active_connections:\n                self.active_connections[session_id] = [\n                    conn for conn in self.active_connections[session_id] \n                    if conn != websocket\n                ]\n                \n                # Clean up empty session\n                if not self.active_connections[session_id]:\n                    del self.active_connections[session_id]\n                else:\n                    self.session_data[session_id]['connection_count'] = len(self.active_connections[session_id])\n            \n            del self.connection_metadata[websocket]\n            logger.info(f\"WebSocket disconnected from session {session_id}\")\n\n    async def send_to_websocket(self, websocket: WebSocket, data: dict):\n        \"\"\"Send data to a specific WebSocket.\"\"\"\n        try:\n            await websocket.send_text(json.dumps(data))\n        except Exception as e:\n            logger.error(f\"Failed to send data to WebSocket: {e}\")\n            # Remove broken connection\n            self.disconnect(websocket)\n\n    async def broadcast_to_session(self, session_id: str, data: dict):\n        \"\"\"Broadcast data to all WebSockets in a session.\"\"\"\n        if session_id not in self.active_connections:\n            return\n        \n        # Update session data\n        self.session_data[session_id]['last_update'] = datetime.now().isoformat()\n        if 'metrics' in data:\n            self.session_data[session_id]['metrics'] = data['metrics']\n        if 'status' in data:\n            self.session_data[session_id]['status'] = data['status']\n        \n        # Broadcast to all connections\n        disconnected = []\n        for websocket in self.active_connections[session_id]:\n            try:\n                await websocket.send_text(json.dumps(data))\n            except Exception as e:\n                logger.error(f\"Failed to broadcast to WebSocket: {e}\")\n                disconnected.append(websocket)\n        \n        # Clean up disconnected WebSockets\n        for ws in disconnected:\n            self.disconnect(ws)\n\n    def get_session_data(self, session_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get current session data.\"\"\"\n        return self.session_data.get(session_id)\n\n    def get_active_sessions(self) -> List[str]:\n        \"\"\"Get list of active session IDs.\"\"\"\n        return list(self.active_connections.keys())\n\n\n# Global WebSocket manager\nmanager = WebSocketManager()\n\n\n# Lifespan context manager\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage application lifespan.\"\"\"\n    logger.info(\"FastAPI WebSocket server starting up...\")\n    yield\n    logger.info(\"FastAPI WebSocket server shutting down...\")\n\n\n# Create FastAPI app\napp = FastAPI(\n    title=\"Agent Forge WebSocket API\",\n    description=\"Real-time progress streaming for Agent Forge training\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# Configure CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\n@app.websocket(\"/ws/{session_id}\")\nasync def websocket_endpoint(websocket: WebSocket, session_id: str):\n    \"\"\"WebSocket endpoint for real-time progress updates.\"\"\"\n    await manager.connect(websocket, session_id)\n    \n    try:\n        while True:\n            # Keep connection alive and handle client messages\n            data = await websocket.receive_text()\n            message = json.loads(data)\n            \n            # Handle client messages\n            if message.get('type') == 'ping':\n                await manager.send_to_websocket(websocket, {\n                    'type': 'pong',\n                    'timestamp': datetime.now().isoformat()\n                })\n            elif message.get('type') == 'get_status':\n                session_data = manager.get_session_data(session_id)\n                await manager.send_to_websocket(websocket, {\n                    'type': 'status_response',\n                    'sessionId': session_id,\n                    'data': session_data\n                })\n            \n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n    except Exception as e:\n        logger.error(f\"WebSocket error: {e}\")\n        manager.disconnect(websocket)\n\n\n@app.get(\"/api/health\")\nasync def health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    return JSONResponse({\n        'status': 'healthy',\n        'websocket_enabled': True,\n        'active_sessions': len(manager.get_active_sessions()),\n        'sessions': manager.get_active_sessions(),\n        'timestamp': datetime.now().isoformat()\n    })\n\n\n@app.get(\"/api/progress/{session_id}\")\nasync def get_session_progress(session_id: str):\n    \"\"\"HTTP endpoint for progress polling (fallback).\"\"\"\n    session_data = manager.get_session_data(session_id)\n    \n    if not session_data:\n        raise HTTPException(status_code=404, detail=\"Session not found\")\n    \n    return JSONResponse({\n        'sessionId': session_id,\n        'metrics': session_data['metrics'],\n        'status': session_data.get('status', 'unknown'),\n        'websocket_available': session_id in manager.active_connections,\n        'connection_count': session_data.get('connection_count', 0),\n        'last_update': session_data.get('last_update'),\n        'timestamp': datetime.now().isoformat()\n    })\n\n\n@app.post(\"/api/progress/{session_id}/update\")\nasync def emit_progress_update(session_id: str, update: ProgressUpdate):\n    \"\"\"API endpoint for emitting progress updates.\"\"\"\n    update.sessionId = session_id\n    \n    # Broadcast to WebSocket clients\n    await manager.broadcast_to_session(session_id, {\n        'type': 'progress_update',\n        'eventType': update.eventType,\n        'sessionId': session_id,\n        'metrics': update.metrics.dict(),\n        'status': update.status,\n        'message': update.message,\n        'timestamp': update.timestamp\n    })\n    \n    return JSONResponse({'status': 'success', 'sessionId': session_id})\n\n\n@app.post(\"/api/progress/{session_id}/error\")\nasync def emit_error(session_id: str, error: ErrorEvent):\n    \"\"\"API endpoint for emitting errors.\"\"\"\n    error.sessionId = session_id\n    \n    # Broadcast error to WebSocket clients\n    await manager.broadcast_to_session(session_id, {\n        'type': 'training_error',\n        'eventType': error.eventType,\n        'sessionId': session_id,\n        'error': error.error,\n        'status': error.status,\n        'timestamp': error.timestamp\n    })\n    \n    return JSONResponse({'status': 'error_sent', 'sessionId': session_id})\n\n\n@app.get(\"/api/sessions\")\nasync def list_active_sessions():\n    \"\"\"List all active sessions.\"\"\"\n    sessions = []\n    \n    for session_id in manager.get_active_sessions():\n        session_data = manager.get_session_data(session_id)\n        sessions.append({\n            'sessionId': session_id,\n            'connectionCount': len(manager.active_connections.get(session_id, [])),\n            'status': session_data.get('status', 'unknown'),\n            'lastUpdate': session_data.get('last_update'),\n            'createdAt': session_data.get('created_at')\n        })\n    \n    return JSONResponse({'sessions': sessions, 'total': len(sessions)})\n\n\n@app.delete(\"/api/sessions/{session_id}\")\nasync def close_session(session_id: str):\n    \"\"\"Close all WebSocket connections for a session.\"\"\"\n    if session_id in manager.active_connections:\n        connections = manager.active_connections[session_id].copy()\n        \n        for websocket in connections:\n            try:\n                await websocket.close(code=1000, reason=\"Session closed by request\")\n            except Exception as e:\n                logger.error(f\"Error closing WebSocket: {e}\")\n            \n            manager.disconnect(websocket)\n        \n        return JSONResponse({'status': 'session_closed', 'sessionId': session_id})\n    else:\n        raise HTTPException(status_code=404, detail=\"Session not found\")\n\n\n# Progress emitter integration\nclass FastAPIProgressEmitter:\n    \"\"\"Progress emitter for integration with training systems.\"\"\"\n    \n    def __init__(self, session_id: str):\n        self.session_id = session_id\n    \n    async def emit_step_update(self, step: int, loss: float, model_idx: int = 0, **kwargs):\n        \"\"\"Emit training step update.\"\"\"\n        metrics = ProgressMetrics(\n            currentStep=step,\n            loss=loss,\n            currentModel=model_idx + 1,\n            perplexity=max(1.0, 2.71828 ** loss),\n            grokProgress=min(100, int((step / kwargs.get('total_steps', 1000)) * 100)),\n            totalSteps=kwargs.get('total_steps', 1000),\n            totalModels=kwargs.get('total_models', 3),\n            **{k: v for k, v in kwargs.items() if k in ProgressMetrics.__fields__}\n        )\n        \n        await manager.broadcast_to_session(self.session_id, {\n            'type': 'progress_update',\n            'eventType': 'step_update',\n            'sessionId': self.session_id,\n            'metrics': metrics.dict(),\n            'status': 'running',\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    async def emit_model_completed(self, model_idx: int, final_loss: float, **kwargs):\n        \"\"\"Emit model completion.\"\"\"\n        metrics = ProgressMetrics(\n            currentModel=model_idx + 1,\n            loss=final_loss,\n            **{k: v for k, v in kwargs.items() if k in ProgressMetrics.__fields__}\n        )\n        \n        await manager.broadcast_to_session(self.session_id, {\n            'type': 'progress_update',\n            'eventType': 'model_completed',\n            'sessionId': self.session_id,\n            'metrics': metrics.dict(),\n            'status': 'running',\n            'message': f'Model {model_idx + 1} completed',\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    async def emit_phase_completed(self, phase_name: str, **kwargs):\n        \"\"\"Emit phase completion.\"\"\"\n        metrics = ProgressMetrics(\n            **{k: v for k, v in kwargs.items() if k in ProgressMetrics.__fields__}\n        )\n        \n        await manager.broadcast_to_session(self.session_id, {\n            'type': 'progress_update',\n            'eventType': 'phase_completed',\n            'sessionId': self.session_id,\n            'metrics': metrics.dict(),\n            'status': 'completed' if 'complete' in phase_name.lower() else 'running',\n            'message': f'Phase {phase_name} completed',\n            'timestamp': datetime.now().isoformat()\n        })\n    \n    async def emit_error(self, error_message: str):\n        \"\"\"Emit training error.\"\"\"\n        await manager.broadcast_to_session(self.session_id, {\n            'type': 'training_error',\n            'eventType': 'training_error',\n            'sessionId': self.session_id,\n            'error': error_message,\n            'status': 'error',\n            'timestamp': datetime.now().isoformat()\n        })\n\n\ndef create_fastapi_emitter(session_id: str) -> FastAPIProgressEmitter:\n    \"\"\"Create FastAPI progress emitter for a session.\"\"\"\n    return FastAPIProgressEmitter(session_id)\n\n\nif __name__ == '__main__':\n    import uvicorn\n    \n    logger.info(\"Starting FastAPI WebSocket server...\")\n    uvicorn.run(\n        app, \n        host=\"0.0.0.0\", \n        port=8001,\n        log_level=\"info\",\n        access_log=True\n    )