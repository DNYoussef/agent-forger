/**\n * WebSocket Progress Component\n * ==========================\n * \n * Enhances existing HTTP polling with real-time WebSocket updates.\n * Maintains backward compatibility and graceful fallback.\n * \n * Features:\n * - WebSocket primary connection with HTTP fallback\n * - Automatic reconnection handling\n * - Compatible with existing metrics format\n * - Zero breaking changes to existing UI\n */\n\nimport React, { useEffect, useState, useCallback, useRef } from 'react';\nimport { io, Socket } from 'socket.io-client';\n\n// Types matching existing polling data format\ninterface ProgressMetrics {\n  loss: number;\n  perplexity: number;\n  grokProgress: number;\n  currentStep: number;\n  totalSteps: number;\n  currentModel: number;\n  totalModels: number;\n  learningRate?: number;\n  accuracy?: number;\n}\n\ninterface ProgressData {\n  sessionId: string;\n  metrics: ProgressMetrics;\n  status: 'running' | 'completed' | 'error' | 'paused';\n  timestamp?: string;\n  message?: string;\n}\n\ninterface WebSocketProgressProps {\n  sessionId: string | null;\n  onMetricsUpdate: (metrics: ProgressMetrics) => void;\n  onStatusUpdate?: (status: string) => void;\n  onError?: (error: string) => void;\n  fallbackPollingInterval?: number;\n  websocketUrl?: string;\n}\n\ninterface ConnectionState {\n  websocket: 'connected' | 'disconnected' | 'connecting' | 'error';\n  fallback: 'active' | 'inactive' | 'error';\n  primary: 'websocket' | 'http';\n}\n\nexport const WebSocketProgress: React.FC<WebSocketProgressProps> = ({\n  sessionId,\n  onMetricsUpdate,\n  onStatusUpdate,\n  onError,\n  fallbackPollingInterval = 1000,\n  websocketUrl = 'ws://localhost:8001'\n}) => {\n  // Connection state\n  const [connectionState, setConnectionState] = useState<ConnectionState>({\n    websocket: 'disconnected',\n    fallback: 'inactive',\n    primary: 'websocket'\n  });\n\n  // Refs for cleanup\n  const socketRef = useRef<Socket | null>(null);\n  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const lastUpdateRef = useRef<number>(0);\n\n  // HTTP polling fallback function\n  const pollProgress = useCallback(async () => {\n    if (!sessionId) return;\n\n    try {\n      const response = await fetch(`http://localhost:8001/api/progress/${sessionId}`);\n      if (response.ok) {\n        const data: ProgressData = await response.json();\n        \n        // Update metrics if data is newer than WebSocket update\n        const updateTime = new Date(data.timestamp || Date.now()).getTime();\n        if (updateTime > lastUpdateRef.current) {\n          onMetricsUpdate(data.metrics);\n          onStatusUpdate?.(data.status);\n          lastUpdateRef.current = updateTime;\n        }\n\n        setConnectionState(prev => ({ ...prev, fallback: 'active' }));\n      }\n    } catch (error) {\n      console.error('HTTP polling failed:', error);\n      setConnectionState(prev => ({ ...prev, fallback: 'error' }));\n    }\n  }, [sessionId, onMetricsUpdate, onStatusUpdate]);\n\n  // Start HTTP polling\n  const startPolling = useCallback(() => {\n    if (pollIntervalRef.current) return;\n\n    pollIntervalRef.current = setInterval(pollProgress, fallbackPollingInterval);\n    setConnectionState(prev => ({ ...prev, fallback: 'active' }));\n    console.log('HTTP polling started as fallback');\n  }, [pollProgress, fallbackPollingInterval]);\n\n  // Stop HTTP polling\n  const stopPolling = useCallback(() => {\n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current);\n      pollIntervalRef.current = null;\n    }\n    setConnectionState(prev => ({ ...prev, fallback: 'inactive' }));\n  }, []);\n\n  // WebSocket connection with automatic fallback\n  const connectWebSocket = useCallback(() => {\n    if (!sessionId || socketRef.current) return;\n\n    console.log(`Connecting to WebSocket: ${websocketUrl}`);\n    setConnectionState(prev => ({ ...prev, websocket: 'connecting' }));\n\n    const socket = io(websocketUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 5000,\n      reconnection: true,\n      reconnectionAttempts: 5,\n      reconnectionDelay: 1000\n    });\n\n    socket.on('connect', () => {\n      console.log('WebSocket connected successfully');\n      setConnectionState(prev => ({ \n        ...prev, \n        websocket: 'connected', \n        primary: 'websocket' \n      }));\n      \n      // Join session room\n      socket.emit('join_room', sessionId);\n      \n      // Stop HTTP polling since WebSocket is working\n      stopPolling();\n    });\n\n    socket.on('disconnect', (reason) => {\n      console.log('WebSocket disconnected:', reason);\n      setConnectionState(prev => ({ \n        ...prev, \n        websocket: 'disconnected',\n        primary: 'http'\n      }));\n      \n      // Start HTTP polling fallback\n      startPolling();\n    });\n\n    socket.on('connect_error', (error) => {\n      console.error('WebSocket connection error:', error);\n      setConnectionState(prev => ({ \n        ...prev, \n        websocket: 'error',\n        primary: 'http'\n      }));\n      \n      // Start HTTP polling fallback immediately\n      startPolling();\n    });\n\n    // Progress update events\n    socket.on('progress_update', (data: ProgressData) => {\n      console.log('WebSocket progress update:', data.eventType, data.metrics);\n      \n      // Update with WebSocket data (always newer)\n      const updateTime = new Date(data.timestamp || Date.now()).getTime();\n      onMetricsUpdate(data.metrics);\n      onStatusUpdate?.(data.status);\n      lastUpdateRef.current = updateTime;\n    });\n\n    socket.on('training_error', (errorData) => {\n      console.error('Training error received:', errorData);\n      onError?.(errorData.error || 'Training error occurred');\n      onStatusUpdate?.('error');\n    });\n\n    socket.on('session_joined', (data) => {\n      console.log('Joined session:', data.sessionId);\n      \n      // Load current state if available\n      if (data.currentState) {\n        onMetricsUpdate(data.currentState);\n      }\n    });\n\n    socketRef.current = socket;\n  }, [sessionId, websocketUrl, onMetricsUpdate, onStatusUpdate, onError, startPolling, stopPolling]);\n\n  // Cleanup function\n  const cleanup = useCallback(() => {\n    if (socketRef.current) {\n      socketRef.current.disconnect();\n      socketRef.current = null;\n    }\n    \n    if (pollIntervalRef.current) {\n      clearInterval(pollIntervalRef.current);\n      pollIntervalRef.current = null;\n    }\n    \n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n  }, []);\n\n  // Main effect - setup connection when sessionId changes\n  useEffect(() => {\n    if (!sessionId) {\n      cleanup();\n      return;\n    }\n\n    // Try WebSocket first\n    connectWebSocket();\n    \n    // Start polling as backup (will be stopped if WebSocket connects)\n    const backupTimeout = setTimeout(() => {\n      if (connectionState.websocket !== 'connected') {\n        console.log('WebSocket not connected, starting HTTP polling backup');\n        startPolling();\n      }\n    }, 2000); // Give WebSocket 2 seconds to connect\n\n    return () => {\n      clearTimeout(backupTimeout);\n      cleanup();\n    };\n  }, [sessionId, connectWebSocket, startPolling, cleanup]);\n\n  // Periodic connection health check\n  useEffect(() => {\n    if (!sessionId) return;\n\n    const healthCheck = setInterval(() => {\n      // If no updates received in 5 seconds and WebSocket claims to be connected\n      const timeSinceLastUpdate = Date.now() - lastUpdateRef.current;\n      \n      if (timeSinceLastUpdate > 5000 && connectionState.websocket === 'connected') {\n        console.log('WebSocket appears stale, activating HTTP fallback');\n        setConnectionState(prev => ({ ...prev, primary: 'http' }));\n        startPolling();\n      }\n    }, 5000);\n\n    return () => clearInterval(healthCheck);\n  }, [sessionId, connectionState.websocket, startPolling]);\n\n  // Return connection status component (for debugging)\n  return (\n    <div className=\"websocket-status\" style={{ \n      position: 'fixed', \n      top: 10, \n      right: 10, \n      padding: '8px', \n      background: 'rgba(0,0,0,0.7)', \n      color: 'white', \n      borderRadius: '4px', \n      fontSize: '12px',\n      zIndex: 1000\n    }}>\n      <div>\n        <strong>Connection Status:</strong>\n      </div>\n      <div>\n        WebSocket: \n        <span style={{ \n          color: connectionState.websocket === 'connected' ? '#4CAF50' : \n                 connectionState.websocket === 'error' ? '#f44336' : '#FF9800' \n        }}>\n          {connectionState.websocket}\n        </span>\n      </div>\n      <div>\n        HTTP Fallback: \n        <span style={{ \n          color: connectionState.fallback === 'active' ? '#4CAF50' : '#666' \n        }}>\n          {connectionState.fallback}\n        </span>\n      </div>\n      <div>\n        <strong>Primary: {connectionState.primary}</strong>\n      </div>\n      {sessionId && (\n        <div style={{ marginTop: '4px', fontSize: '10px', opacity: 0.8 }}>\n          Session: {sessionId.substring(0, 8)}...\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Hook for using WebSocket progress in existing components\nexport const useWebSocketProgress = (sessionId: string | null) => {\n  const [metrics, setMetrics] = useState<ProgressMetrics>(\n    null\n  );\n  const [status, setStatus] = useState<string>('waiting');\n  const [error, setError] = useState<string | null>(null);\n\n  const handleMetricsUpdate = useCallback((newMetrics: ProgressMetrics) => {\n    setMetrics(newMetrics);\n  }, []);\n\n  const handleStatusUpdate = useCallback((newStatus: string) => {\n    setStatus(newStatus);\n  }, []);\n\n  const handleError = useCallback((errorMessage: string) => {\n    setError(errorMessage);\n  }, []);\n\n  return {\n    metrics,\n    status,\n    error,\n    WebSocketProgressComponent: () => (\n      <WebSocketProgress\n        sessionId={sessionId}\n        onMetricsUpdate={handleMetricsUpdate}\n        onStatusUpdate={handleStatusUpdate}\n        onError={handleError}\n      />\n    )\n  };\n};\n\nexport default WebSocketProgress;